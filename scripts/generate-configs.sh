#!/usr/bin/env bash
# =============================================================================
# DYNAMIC SHELL CONFIGURATION GENERATOR
# Creates shell-specific configurations based on detected modules
# =============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DOTFILES_DIR="$(dirname "$SCRIPT_DIR")"
DETECTION_SCRIPT="$SCRIPT_DIR/dynamic-modules.sh"

# Source the detection script
source "$DETECTION_SCRIPT"

# =============================================================================
# BASH CONFIGURATION GENERATOR
# =============================================================================

generate_bash_config() {
    local output_file="$1"
    echo -e "${COLORS[yellow]}ðŸ”§ Generating Bash configuration...${COLORS[reset]}"
    
    cat > "$output_file" << 'EOF'
#!/usr/bin/env bash
# =============================================================================
# DYNAMICALLY GENERATED BASH CONFIGURATION
# Generated by dynamic shell configurator
# =============================================================================

# Load dynamic detection
DETECTION_SCRIPT="$(dirname "${BASH_SOURCE[0]}")/../scripts/dynamic-modules.sh"
if [[ -f "$DETECTION_SCRIPT" ]]; then
    source "$DETECTION_SCRIPT"
    detect_all_modules
fi

# =============================================================================
# CORE BASH SETTINGS
# =============================================================================

# History settings
HISTSIZE=10000
HISTFILESIZE=20000
HISTCONTROL=ignoreboth:erasedups
shopt -s histappend
shopt -s cmdhist

# Navigation settings
shopt -s cdspell
shopt -s dirspell

# Completion
if ! shopt -oq posix; then
    if [[ -f /usr/share/bash-completion/bash_completion ]]; then
        source /usr/share/bash-completion/bash_completion
    elif [[ -f /etc/bash_completion ]]; then
        source /etc/bash_completion
    fi
fi

# =============================================================================
# DYNAMIC ALIASES
# =============================================================================

EOF
    
    # Add conditional tool integrations
    if command -v fzf &>/dev/null; then
        cat >> "$output_file" << 'EOF'
# FZF integration
if [[ -f /usr/share/fzf/key-bindings.bash ]]; then
    source /usr/share/fzf/key-bindings.bash 2>/dev/null
elif [[ -f /usr/share/doc/fzf/examples/key-bindings.bash ]]; then
    source /usr/share/doc/fzf/examples/key-bindings.bash 2>/dev/null
elif [[ -f ~/.fzf.bash ]]; then
    source ~/.fzf.bash 2>/dev/null
fi

EOF
    fi
    
    if command -v zoxide &>/dev/null; then
        cat >> "$output_file" << 'EOF'
# Zoxide integration
eval "$(zoxide init bash)"

EOF
    fi
    
    if command -v thefuck &>/dev/null; then
        cat >> "$output_file" << 'EOF'
# TheFuck integration
eval "$(thefuck --alias)"

EOF
    fi
    
    # Add Starship prompt if available
    if command -v starship &>/dev/null; then
        cat >> "$output_file" << 'EOF'
# Starship prompt
eval "$(starship init bash)"

EOF
    fi
    
    cat >> "$output_file" << 'EOF'

# Load generated aliases
DYNAMIC_ALIASES="$(dirname "${BASH_SOURCE[0]}")/../tmp/dynamic-bash.sh"
[[ -f "$DYNAMIC_ALIASES" ]] && source "$DYNAMIC_ALIASES"

# =============================================================================
# DYNAMIC FUNCTIONS
# =============================================================================

# Dynamic function generation based on available tools
if command -v fzf &>/dev/null; then
    # Enhanced fuzzy search functions
    fzf-history() {
        local cmd
        cmd=$(history | fzf --tac +s --query="$1" | sed 's/^[ ]*[0-9]*[ ]*//')
        [[ -n "$cmd" ]] && echo "$cmd" && eval "$cmd"
    }
    
    fzf-file() {
        local files
        IFS=$'\n' files=($(fzf --query="$1" --multi --select-1 --exit-0 --preview 'bat --style=numbers --color=always --line-range :500 {} 2>/dev/null || cat {}'))
        [[ -n "$files" ]] && ${EDITOR:-vim} "${files[@]}"
    }
fi

if command -v git &>/dev/null; then
    # Enhanced git functions
    git-branch-fzf() {
        local branches branch
        branches=$(git branch -vv)
        branch=$(echo "$branches" | fzf --height=20 --reverse +m)
        git checkout $(echo "$branch" | awk '{print $1}' | sed "s/.* //")
    }
fi

if command -v docker &>/dev/null; then
    # Enhanced docker functions
    docker-exec() {
        local container
        container=$(docker ps --format "{{.Names}}\t{{.Image}}" | fzf --header="Select container to exec into:" | awk '{print $1}')
        [[ -n "$container" ]] && docker exec -it "$container" bash
    }
    
    docker-logs() {
        local container
        container=$(docker ps --format "{{.Names}}\t{{.Image}}" | fzf --header="Select container to view logs:" | awk '{print $1}')
        [[ -n "$container" ]] && docker logs -f "$container"
    }
fi

if command -v kubectl &>/dev/null; then
    # Enhanced kubectl functions
    kubectl-logs() {
        local pod
        pod=$(kubectl get pods --no-headers | awk '{print $1}' | fzf --header="Select pod to view logs:")
        [[ -n "$pod" ]] && kubectl logs -f "$pod"
    }
    
    kubectl-exec() {
        local pod
        pod=$(kubectl get pods --no-headers | awk '{print $1}' | fzf --header="Select pod to exec into:")
        [[ -n "$pod" ]] && kubectl exec -it "$pod" -- bash
    }
fi

EOF
}

# =============================================================================
# ZSH CONFIGURATION GENERATOR
# =============================================================================

generate_zsh_config() {
    local output_file="$1"
    echo -e "${COLORS[yellow]}ðŸ”§ Generating Zsh configuration...${COLORS[reset]}"
    
    cat > "$output_file" << 'EOF'
#!/usr/bin/env zsh
# =============================================================================
# DYNAMICALLY GENERATED ZSH CONFIGURATION
# Generated by dynamic shell configurator
# =============================================================================

# Load dynamic detection
DETECTION_SCRIPT="$(dirname "${(%):-%x}")/../scripts/dynamic-modules.sh"
if [[ -f "$DETECTION_SCRIPT" ]]; then
    source "$DETECTION_SCRIPT"
    detect_all_modules
fi

# =============================================================================
# CORE ZSH SETTINGS
# =============================================================================

# History
HISTFILE=~/.zsh_history
HISTSIZE=10000
SAVEHIST=10000
setopt HIST_IGNORE_DUPS
setopt HIST_IGNORE_SPACE
setopt SHARE_HISTORY
setopt EXTENDED_HISTORY

# Navigation
setopt AUTO_CD
setopt CDABLEVARS

# Completion
autoload -Uz compinit
compinit -u 2>/dev/null || compinit
zstyle ':completion:*' menu select
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}'

EOF
    
    # Add Oh-My-Zsh conditionally
    cat >> "$output_file" << 'EOF'
# Oh-My-Zsh (if available)
if [[ -d "$HOME/.oh-my-zsh" ]]; then
    export ZSH="$HOME/.oh-my-zsh"
    
    # Dynamic plugins based on availability
    plugins=(
        git
        sudo
        history
        colored-man-pages
        command-not-found
    )
    
    # Add fzf if available
    command -v fzf &>/dev/null && plugins+=(fzf)
    
    # Add docker if available
    command -v docker &>/dev/null && plugins+=(docker)
    
    # Add kubectl if available
    command -v kubectl &>/dev/null && plugins+=(kubectl)
    
    # Source Oh-My-Zsh
    [[ -f "$ZSH/oh-my-zsh.sh" ]] && source "$ZSH/oh-my-zsh.sh"
fi

EOF
    
    # Add syntax highlighting if available
    cat >> "$output_file" << 'EOF'
# Syntax highlighting (if available)
if [[ -f /usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ]]; then
    source /usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
elif [[ -f /usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ]]; then
    source /usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
fi

# Auto-suggestions (if available)
if [[ -f /usr/share/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh ]]; then
    source /usr/share/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh
elif [[ -f /usr/share/zsh-autosuggestions/zsh-autosuggestions.zsh ]]; then
    source /usr/share/zsh-autosuggestions/zsh-autosuggestions.zsh
fi

EOF
    
    # Add Starship prompt if available
    cat >> "$output_file" << 'EOF'
# Starship prompt (if available)
if command -v starship &>/dev/null; then
    eval "$(starship init zsh)"
fi

# Zoxide integration (if available)
if command -v zoxide &>/dev/null; then
    eval "$(zoxide init zsh)"
fi

# Load generated aliases
DYNAMIC_ALIASES="$(dirname "${(%):-%x}")/../tmp/dynamic-zsh.sh"
[[ -f "$DYNAMIC_ALIASES" ]] && source "$DYNAMIC_ALIASES"

EOF
    
    cat >> "$output_file" << 'EOF'

# =============================================================================
# DYNAMIC FUNCTIONS FOR ZSH
# =============================================================================

# Enhanced fuzzy search with Zsh
if command -v fzf &>/dev/null; then
    # History search with fzf
    fzf-history-widget() {
        local selected
        selected=$(history -t 1 | fzf --tac +s --query="$LBUFFER" | sed 's/^[ ]*[0-9]*[ ]*//')
        if [[ -n "$selected" ]]; then
            LBUFFER="$selected"
        fi
        zle redisplay
    }
    zle -N fzf-history-widget
    bindkey '^R' fzf-history-widget
    
    # File search with fzf
    fzf-file-widget() {
        local files
        IFS=$'\n' files=($(fzf --query="$LBUFFER" --multi --select-1 --exit-0 --preview 'bat --style=numbers --color=always --line-range :500 {} 2>/dev/null || cat {}'))
        if [[ -n "$files" ]]; then
            LBUFFER="${EDITOR:-vim} ${files[*]}"
        fi
        zle redisplay
    }
    zle -N fzf-file-widget
    bindkey '^T' fzf-file-widget
fi

# Directory completion with fzf
if command -v fd &>/dev/null && command -v fzf &>/dev/null; then
    fzf-cd-widget() {
        local dir
        dir=$(fd --type d --hidden --follow --exclude ".git" . | fzf --preview 'tree -C {} | head -200')
        if [[ -n "$dir" ]]; then
            cd "$dir"
        fi
        zle redisplay
    }
    zle -N fzf-cd-widget
    bindkey '^E' fzf-cd-widget
fi

EOF
}

# =============================================================================
# FISH CONFIGURATION GENERATOR
# =============================================================================

generate_fish_config() {
    local output_file="$1"
    echo -e "${COLORS[yellow]}ðŸ”§ Generating Fish configuration...${COLORFIX[reset]}"
    
    cat > "$output_file" << 'EOF'
# =============================================================================
# DYNAMICALLY GENERATED FISH CONFIGURATION
# Generated by dynamic shell configurator
# =============================================================================

# Fish shell-specific settings
set -g fish_greeting ""

# History settings
set -g fish_history_max_size 10000

EOF
    
    # Add dynamic tool integrations
    cat >> "$output_file" << 'EOF'

# FZF integration (if available)
if command -v fzf &>/dev/null
    if test -f /usr/share/fzf/key-bindings.fish
        source /usr/share/fzf/key-bindings.fish
    end
end

# Starship prompt (if available)
if command -v starship &>/dev/null
    starship init fish | source
end

# Zoxide integration (if available)
if command -v zoxide &>/dev/null
    zoxide init fish | source
end

# TheFuck integration (if available)
if command -v thefuck &>/dev/null
    thefuck --alias | source
end

EOF
    
    cat >> "$output_file" << 'EOF'

# =============================================================================
# DYNAMIC FUNCTIONS FOR FISH
# =============================================================================

# Enhanced fuzzy search
if command -v fzf &>/dev/null
    function fzf_history
        history | fzf --tac +s --query=(commandline) | read -l result
        and commandline -- $result
    end
    
    function fzf_file
        fzf --multi --preview 'bat --style=numbers --color=always --line-range :500 {} 2>/dev/null or cat {}' | xargs $EDITOR
    end
    
    bind \cr fzf_history
    bind \ct fzf_file
end

if command -v fd &>/dev/null and command -v fzf &>/dev/null
    function fzf_cd
        fd --type d --hidden --follow --exclude ".git" . | fzf --preview 'tree -C {} | head -200' | read -l result
        and cd $result
        commandline -f repaint
    end
    
    bind \ce fzf_cd
end

EOF
}

# =============================================================================
# NUSHELL CONFIGURATION GENERATOR
# =============================================================================

generate_nushell_config() {
    local output_file="$1"
    echo -e "${COLORS[yellow]}ðŸ”§ Generating Nushell configuration...${COLORS[reset]}"
    
    cat > "$output_file" << 'EOF'
# =============================================================================
# DYNAMICALLY GENERATED NUSHELL CONFIGURATION
# Generated by dynamic shell configurator
# =============================================================================

# Core Nushell settings
$env.config = {
    show_banner: false
    rm_always_trash: true
    table: {
        mode: compact
        index_mode: always
    }
    history: {
        max_size: 10000
        sync_on_enter: true
    }
    completions: {
        case_sensitive: false
        quick: true
        partial: true
        algorithm: "fuzzy"
    }
}

EOF
    
    # Add dynamic tool integrations for Nushell
    cat >> "$output_file" << 'EOF'

# Dynamic tool integrations

# Carapet integration (if available)
if (which carapace | is-not-empty) {
    carapace _carapace | source
}

# Starship prompt (if available)
if (which starship | is-not-empty) {
    starship init nu | save -f /tmp/starship_init.nu
    source /tmp/starship_init.nu
}

# Zoxide integration (if available)
if (which zoxide | is-not-empty) {
    zoxide init --cmd cd nushell | save -f /tmp/zoxide_init.nu
    source /tmp/zoxide_init.nu
}

EOF
    
    cat >> "$output_file" << 'EOF'

# =============================================================================
# DYNAMIC COMMANDS FOR NUSHELL
# =============================================================================

# Enhanced fuzzy search commands
if (which fzf | is-not-empty) {
    def fzf-history [] {
        history | fzf --tac --query ($env.CURRENT_COMMAND | default "") | str trim
    }
    
    def fzf-file [pattern?: string] {
        fzf --multi --preview $"bat --style=numbers --color=always --line-range :500 {} 2>/dev/null or cat {}" | xargs $env.EDITOR
    }
}

if (which fd | is-not-empty) and (which fzf | is-not-empty) {
    def fzf-cd [] {
        let dir = (fd --type d --hidden --follow --exclude ".git" . | fzf --preview "tree -C {} | head -200")
        if $dir != "" {
            cd $dir
        }
    }
}

# Enhanced git commands
if (which git | is-not-empty) {
    def git-branch-fzf [] {
        let branches = (git branch --verbose)
        let branch = ($branches | fzf --height 20 --reverse +m)
        if $branch != "" {
            git checkout ($branch | str trim | split column ' ' | get 0 | get 0)
        }
    }
}

# Enhanced docker commands
if (which docker | is-not-empty) {
    def docker-exec [] {
        let container = (docker ps --format "{{.Names}}\t{{.Image}}" | fzf --header "Select container to exec into:" | split column "\t" | get 0 | get 0)
        if $container != "" {
            docker exec -it $container nu
        }
    }
    
    def docker-logs [] {
        let container = (docker ps --format "{{.Names}}\t{{.Image}}" | fzf --header "Select container to view logs:" | split column "\t" | get 0 | get 0)
        if $container != "" {
            docker logs -f $container
        }
    }
}

# Enhanced kubectl commands
if (which kubectl | is-not-empty) {
    def kubectl-logs [] {
        let pod = (kubectl get pods --no-headers | awk '{print $1}' | fzf --header "Select pod to view logs:")
        if $pod != "" {
            kubectl logs -f $pod
        }
    }
    
    def kubectl-exec [] {
        let pod = (kubectl get pods --no-headers | awk '{print $1}' | fzf --header "Select pod to exec into:")
        if $pod != "" {
            kubectl exec -it $pod -- nu
        }
    }
}

EOF
}

# =============================================================================
# MAIN GENERATION FUNCTION
# =============================================================================

main() {
    local shell_type="${1:-all}"
    local output_dir="${2:-$DOTFILES_DIR/generated}"
    
    echo -e "${COLORS[cyan]}ðŸš€ Starting dynamic shell configuration generation...${COLORS[reset]}"
    
    # Detect all modules first
    detect_all_modules
    
    # Create output directory
    mkdir -p "$output_dir"
    mkdir -p "$output_dir/tmp"
    
    # Generate shell-specific configurations
    case "$shell_type" in
        "bash")
            generate_bash_config "$output_dir/dynamic-bash.sh"
            ;;
        "zsh")
            generate_zsh_config "$output_dir/dynamic-zsh.sh"
            ;;
        "fish")
            generate_fish_config "$output_dir/dynamic-fish.fish"
            ;;
        "nushell"|"nu")
            generate_nushell_config "$output_dir/dynamic-nu.nu"
            ;;
        "all")
            generate_bash_config "$output_dir/dynamic-bash.sh"
            generate_zsh_config "$output_dir/dynamic-zsh.sh"
            generate_fish_config "$output_dir/dynamic-fish.fish"
            generate_nushell_config "$output_dir/dynamic-nu.nu"
            ;;
        *)
            echo -e "${COLORS[red]}âŒ Unknown shell type: $shell_type${COLORS[reset]}"
            echo "Available: bash, zsh, fish, nushell, all"
            exit 1
            ;;
    esac
    
    echo -e "${COLORS[green]}âœ… Dynamic configurations generated in $output_dir${COLORS[reset]}"
    
    # Generate summary report
    cat > "$output_dir/generated-report.txt" << EOF
Dynamic Dotfiles Generation Report
Generated on: $(date)
Total tools detected: ${#DETECTED_TOOLS[@]}
Total features available: ${#AVAILABLE_FEATURES[@]}

Detected Tools:
$(for tool in "${!DETECTED_TOOLS[@]}"; do echo "  â€¢ $tool: ${DETECTED_TOOLS[$tool]}"; done)

Available Features:
$(for feature in "${!AVAILABLE_FEATURES[@]}"; do echo "  â€¢ $feature (${AVAILABLE_FEATURES[$feature]} priority)"; done)
EOF
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi